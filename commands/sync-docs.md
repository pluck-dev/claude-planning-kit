# /sync-docs - 기능명세서 동기화 (전역)

현재 프로젝트의 코드베이스와 기능명세서 문서를 비교하여 동기화합니다.

## 수행 절차

### Step 1: 프로젝트 구조 감지

1. 기능명세서 위치를 탐색합니다:
   - `docs/functional-spec/` (우선)
   - `docs/spec/`
   - `docs/`
   - 없으면 사용자에게 위치를 물어봅니다.

2. 코드베이스 구조를 파악합니다:
   - DB 스키마: `prisma/schema.prisma`, `drizzle/schema.ts`, `schema.sql`, `migrations/`
   - API 라우트: `src/app/api/`, `src/routes/`, `pages/api/`, `src/controllers/`
   - 서비스 레이어: `src/services/`, `src/lib/`, `src/utils/`
   - 미들웨어: `src/middleware.*`, `src/middlewares/`

### Step 2: 변경 범위 결정

인자가 있으면 ($ARGUMENTS) 해당 범위만 확인합니다:
- `/sync-docs` → 전체 문서 동기화
- `/sync-docs contract` → 계약 관련 문서만
- `/sync-docs schema` → 데이터 모델 섹션만

인자가 없으면 git diff로 최근 변경 파일을 확인하여 영향받는 문서를 자동 판별합니다.

### Step 3: 코드-문서 매핑

`CLAUDE.md`에 매핑표가 있으면 그것을 사용합니다. 없으면 자동으로 추론합니다:

**자동 추론 규칙:**
- 스키마 파일 변경 → 모든 문서의 데이터 모델 섹션
- 서비스 파일 변경 → 해당 도메인 문서 (파일명 기준 매칭)
- API 라우트 변경 → 해당 도메인 문서
- 미들웨어/인증 변경 → 인증/권한 문서

### Step 4: 비교 및 수정

영향받는 각 문서에 대해:

1. **문서를 읽습니다**
2. **관련 코드를 읽습니다** (스키마, 서비스, API 라우트)
3. **불일치를 찾습니다:**
   - 데이터 모델: 필드명, 타입, nullable, 기본값
   - 비즈니스 로직: 삭제 방식, 상태 전이, 필터/정렬 조건
   - API: 엔드포인트, 요청/응답 형식
   - 코드에 있지만 문서에 없는 기능
   - 문서에 있지만 코드에 없는 기능
4. **코드 기준으로 문서를 수정합니다**

### Step 5: 결과 보고

수정한 내용을 요약 보고합니다:
- 수정된 문서 목록
- 각 문서별 주요 변경 사항
- 심각도 분류 (높음: 비즈니스 로직 차이, 중간: 포맷/필터 차이, 낮음: 세부 필드 차이)

## 중요 원칙

- **코드가 진실의 원천(source of truth)**입니다.
- 문서의 기존 형식과 스타일을 유지하면서 내용만 수정합니다.
- 문서 내부 일관성도 체크합니다 (같은 내용이 여러 곳에 있으면 모두 수정).
- 수정 시 반드시 실제 코드를 읽어서 확인합니다. 추측하지 않습니다.
